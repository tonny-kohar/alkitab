/* This work has been placed into the public domain. */

package kiyut.alkitab.bookviewer;

import java.awt.CardLayout;
import java.awt.Component;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.ResourceBundle;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JComboBox;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.HyperlinkListener;
import kiyut.alkitab.bookviewer.event.BookChangeEvent;
import kiyut.alkitab.history.BookViewerHistory;
import kiyut.alkitab.history.BookViewerHistoryManager;
import kiyut.alkitab.history.GlobalHistory;
import kiyut.alkitab.history.History;
import kiyut.alkitab.history.HistoryManager;
import kiyut.alkitab.options.BookViewerOptions;
import kiyut.alkitab.options.ViewerHintsOptions;
import kiyut.alkitab.util.Indexer;
import kiyut.alkitab.util.SwordUtilities;
import kiyut.swing.combo.SeparatorComboBox;
import org.crosswire.jsword.book.Book;
import org.crosswire.jsword.book.BookCategory;
import org.crosswire.jsword.book.BookFilters;
import org.crosswire.jsword.book.Books;
import org.crosswire.jsword.index.IndexStatus;
import org.crosswire.jsword.index.search.DefaultSearchModifier;
import org.crosswire.jsword.index.search.DefaultSearchRequest;
import org.crosswire.jsword.passage.Key;
import org.crosswire.jsword.passage.Passage;
import org.crosswire.jsword.passage.PassageTally;
import org.crosswire.jsword.passage.RestrictionType;
import org.netbeans.api.progress.ProgressHandle;
import org.netbeans.api.progress.ProgressHandleFactory;
import org.openide.util.RequestProcessor;

/**
 * Implementation of {@link kiyut.alkitab.api.BookViewer BookViewer} which able to display parallel book
 * 
 * @author Tonny Kohar <tonny.kohar@gmail.com>
 */
public class ParallelBookViewerPane extends AbstractBookViewerPane {
    
    protected ResourceBundle bundle = ResourceBundle.getBundle(ParallelBookViewerPane.class.getName());
    
    //protected transient TextPaneRenderer bookRenderer;
    protected transient WebViewRenderer bookRenderer;

    /** just a flag indicating searching mode */
    protected boolean searching;

    private String searchString;

    protected ActionListener bookComboActionListener;
    
    protected HistoryManager historyManager;

    /** just a flag indicating history is in progress */
    protected boolean historyInProgress;
    
    protected volatile boolean unindexedBooks; 
    protected volatile boolean indexInProgress;  
    //protected List<Progress> indexJobs;
    //protected IndexWorkListener indexWorkListener;

    protected ChangeListener indexChangeListener;
    
    /** Creates new ParallelBookViewerPane. */
    public ParallelBookViewerPane() {
        initComponents();
        initCustom();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        splitPane = new javax.swing.JSplitPane();
        topPane = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jToolBar1 = new javax.swing.JToolBar();
        addBookButton = new javax.swing.JButton();
        removeBookButton = new javax.swing.JButton();
        booksComboPane = new javax.swing.JPanel();
        compareCheckBox = new javax.swing.JCheckBox();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        passagePane = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        passageTextArea = new javax.swing.JTextArea();
        jToolBar2 = new javax.swing.JToolBar();
        passageGoButton = new javax.swing.JButton();
        passageChooserButton = new javax.swing.JButton();
        searchPane = new javax.swing.JPanel();
        jPanel4 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        searchTextArea = new javax.swing.JTextArea();
        jToolBar3 = new javax.swing.JToolBar();
        searchGoButton = new javax.swing.JButton();
        advancedSearchButton = new javax.swing.JButton();
        jPanel5 = new javax.swing.JPanel();
        indexButton = new javax.swing.JButton();

        setLayout(new java.awt.BorderLayout());

        splitPane.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);

        topPane.setBorder(javax.swing.BorderFactory.createEmptyBorder(6, 6, 6, 6));
        topPane.setLayout(new java.awt.GridBagLayout());

        jLabel1.setText(bundle.getString("CTL_Book.Text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_END;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 6);
        topPane.add(jLabel1, gridBagConstraints);

        jToolBar1.setFloatable(false);
        jToolBar1.setRollover(true);

        addBookButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/kiyut/alkitab/bookviewer/plus.png"))); // NOI18N
        addBookButton.setToolTipText(bundle.getString("HINT_AddBook.Text")); // NOI18N
        addBookButton.setFocusable(false);
        addBookButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        addBookButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar1.add(addBookButton);

        removeBookButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/kiyut/alkitab/bookviewer/minus.png"))); // NOI18N
        removeBookButton.setToolTipText(bundle.getString("HINT_RemoveBook.Text")); // NOI18N
        removeBookButton.setFocusable(false);
        removeBookButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        removeBookButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar1.add(removeBookButton);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        topPane.add(jToolBar1, gridBagConstraints);

        java.awt.FlowLayout flowLayout1 = new java.awt.FlowLayout(java.awt.FlowLayout.CENTER, 5, 0);
        flowLayout1.setAlignOnBaseline(true);
        booksComboPane.setLayout(flowLayout1);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 6, 0, 0);
        topPane.add(booksComboPane, gridBagConstraints);

        compareCheckBox.setText(bundle.getString("CTL_Compare.Text")); // NOI18N
        compareCheckBox.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_END;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 3);
        topPane.add(compareCheckBox, gridBagConstraints);

        jLabel2.setText(bundle.getString("CTL_Search.Text")); // NOI18N
        jLabel2.setToolTipText(bundle.getString("HINT_Search.Text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.ABOVE_BASELINE_TRAILING;
        gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 6);
        topPane.add(jLabel2, gridBagConstraints);

        jLabel3.setText(bundle.getString("CTL_Passsage.Text")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.ABOVE_BASELINE_TRAILING;
        gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 6);
        topPane.add(jLabel3, gridBagConstraints);

        passagePane.setLayout(new java.awt.GridBagLayout());

        passageTextArea.setLineWrap(true);
        passageTextArea.setWrapStyleWord(true);
        jScrollPane1.setViewportView(passageTextArea);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        passagePane.add(jScrollPane1, gridBagConstraints);

        jToolBar2.setFloatable(false);
        jToolBar2.setRollover(true);

        passageGoButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/kiyut/alkitab/bookviewer/go.png"))); // NOI18N
        passageGoButton.setToolTipText(bundle.getString("HINT_PassageGo.Text")); // NOI18N
        passageGoButton.setFocusable(false);
        passageGoButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        passageGoButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar2.add(passageGoButton);

        passageChooserButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/kiyut/alkitab/bookviewer/edit.png"))); // NOI18N
        passageChooserButton.setToolTipText(bundle.getString("HINT_PassageChooser.Text")); // NOI18N
        passageChooserButton.setFocusable(false);
        passageChooserButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        passageChooserButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar2.add(passageChooserButton);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.VERTICAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.FIRST_LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);
        passagePane.add(jToolBar2, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
        topPane.add(passagePane, gridBagConstraints);

        searchPane.setLayout(new java.awt.CardLayout());

        jPanel4.setLayout(new java.awt.GridBagLayout());

        searchTextArea.setLineWrap(true);
        searchTextArea.setWrapStyleWord(true);
        jScrollPane2.setViewportView(searchTextArea);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        jPanel4.add(jScrollPane2, gridBagConstraints);

        jToolBar3.setFloatable(false);
        jToolBar3.setRollover(true);

        searchGoButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/kiyut/alkitab/bookviewer/go.png"))); // NOI18N
        searchGoButton.setToolTipText(bundle.getString("HINT_PassageGo.Text")); // NOI18N
        searchGoButton.setFocusable(false);
        searchGoButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        searchGoButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar3.add(searchGoButton);

        advancedSearchButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/kiyut/alkitab/bookviewer/edit.png"))); // NOI18N
        advancedSearchButton.setToolTipText(bundle.getString("HINT_AdvancedSearch.Text")); // NOI18N
        advancedSearchButton.setFocusable(false);
        advancedSearchButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        advancedSearchButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar3.add(advancedSearchButton);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.VERTICAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.FIRST_LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 3);
        jPanel4.add(jToolBar3, gridBagConstraints);

        searchPane.add(jPanel4, "search-layout");

        jPanel5.setLayout(new javax.swing.BoxLayout(jPanel5, javax.swing.BoxLayout.LINE_AXIS));

        indexButton.setText(bundle.getString("CTL_NoIndex.Text")); // NOI18N
        jPanel5.add(indexButton);

        searchPane.add(jPanel5, "index-layout");

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
        topPane.add(searchPane, gridBagConstraints);

        splitPane.setLeftComponent(topPane);

        add(splitPane, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addBookButton;
    private javax.swing.JButton advancedSearchButton;
    private javax.swing.JPanel booksComboPane;
    private javax.swing.JCheckBox compareCheckBox;
    private javax.swing.JButton indexButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JToolBar jToolBar2;
    private javax.swing.JToolBar jToolBar3;
    private javax.swing.JButton passageChooserButton;
    private javax.swing.JButton passageGoButton;
    private javax.swing.JPanel passagePane;
    private javax.swing.JTextArea passageTextArea;
    private javax.swing.JButton removeBookButton;
    private javax.swing.JButton searchGoButton;
    private javax.swing.JPanel searchPane;
    private javax.swing.JTextArea searchTextArea;
    private javax.swing.JSplitPane splitPane;
    private javax.swing.JPanel topPane;
    // End of variables declaration//GEN-END:variables
 
    protected void initCustom() {
        unindexedBooks = false;
        indexInProgress = false;

        BookViewerOptions opts = BookViewerOptions.getInstance();
        maximumBook = opts.getParallelBookLimit();
        historyManager = new BookViewerHistoryManager();
               
        //splitPane.setOneTouchExpandable(true);

        ViewerHints<ViewerHints.Key,Object> viewerHints = new ViewerHints<>(ViewerHintsOptions.getInstance().getViewerHints());
        
        //JScrollPane bookScrollPane = new JScrollPane();
        //bookRenderer = new TextPaneRenderer(viewerHints);
        //bookScrollPane.setViewportView(bookRenderer);
        //splitPane.setRightComponent(bookScrollPane);
        bookRenderer = new WebViewRenderer(viewerHints);
        splitPane.setRightComponent(bookRenderer);
        
        //getActionMap().setParent(bookRenderer.getActionMap());

        // XXX workaround for Windows Plaf for button margin
        Insets insets = new Insets(0, 0, 0, 0);
        addBookButton.setMargin(insets);
        removeBookButton.setMargin(insets);
        passageGoButton.setMargin(insets);
        passageChooserButton.setMargin(insets);
        searchGoButton.setMargin(insets);
        advancedSearchButton.setMargin(insets);
        
        addBookButton.addActionListener((ActionEvent evt) -> {
            boolean added = addBook(null);
            if (added) {
                reload();
            }
        });
        
        removeBookButton.addActionListener((ActionEvent evt) -> {
            boolean removed = removeBook(booksComboPane.getComponentCount()-1);
            if (removed) {
                reload();
            }
        });
        
        bookComboActionListener = (ActionEvent evt) -> {
            Object comboBox = evt.getSource();
            int index = -1;
            for (int i = 0; i < booksComboPane.getComponentCount(); i++) {
                if (comboBox.equals(booksComboPane.getComponent(i))) {
                    index = i;
                    break;
                }
            }
            if (index == -1) {
                return;
            }
            
            String bookName = ((JComboBox)comboBox).getSelectedItem().toString();
            setBook(index, bookName);
            reload();
        };
        
        compareCheckBox.addActionListener((ActionEvent evt) -> {
            compareView(compareCheckBox.isSelected());
            reload();
        });
        
        passageChooserButton.addActionListener((ActionEvent evt) -> {
            PassageChooser passageChooser = new PassageChooser();
            passageChooser.setPassage(passageTextArea.getText());
            int choice = passageChooser.showDialog(ParallelBookViewerPane.this);
            if (choice != JOptionPane.OK_OPTION) {
                return;
            }
            Key key = passageChooser.getKey();
            viewPassage(key);
            //setKey(key);
            //refresh();
        });
        
        passageGoButton.addActionListener((ActionEvent evt) -> {
            String str = passageTextArea.getText();
            viewPassage(str);
            //setKey(str);
            //refresh();
        });
        
        advancedSearchButton.addActionListener((ActionEvent evt) -> {
            SearchPane searchPane1 = new SearchPane();
            searchPane1.setRanked(false);
            searchPane1.setSearchLimit(BookViewerOptions.getInstance().getDefaultSearchLimit());
            int choice = searchPane1.showDialog(ParallelBookViewerPane.this);
            if (choice != JOptionPane.OK_OPTION) {
                return;
            }
            boolean ranked = searchPane1.isRanked();
            int searchLimit = searchPane1.getSearchLimit();
            searchTextArea.setText(searchPane1.getSearchString());
            search(searchTextArea.getText(),ranked,searchLimit);
        });
        
        searchGoButton.addActionListener((ActionEvent evt) -> {
            search(searchTextArea.getText());
        });
        
        passageTextArea.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent evt) {
                if (evt.getKeyCode() != KeyEvent.VK_ENTER) {
                    return;
                }
                evt.consume();
                
                boolean ctrlDown = false;
                if ((evt.getModifiersEx() & KeyEvent.CTRL_DOWN_MASK) == KeyEvent.CTRL_DOWN_MASK) {
                    ctrlDown = true;
                }
                
                if (ctrlDown) {
                    passageChooserButton.doClick();
                } else {
                    viewPassage(passageTextArea.getText());
                    

                }
            }
        });
        
        searchTextArea.addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent evt) {
                if (evt.getKeyCode() != KeyEvent.VK_ENTER) {
                    return;
                }
                
                evt.consume();
                
                boolean ctrlDown = false;
                if ((evt.getModifiersEx() & KeyEvent.CTRL_DOWN_MASK) == KeyEvent.CTRL_DOWN_MASK) {
                    ctrlDown = true;
                }
                
                if (ctrlDown) {
                    advancedSearchButton.doClick();
                } else {
                    search(searchTextArea.getText());
                    //refresh();
                }
            }
        });
        
        indexButton.addActionListener((ActionEvent evt) -> {
            List<Book> books = bookRenderer.getBooks();
            if (!books.isEmpty()) {
                Indexer.getInstance().createIndex(books.get(0),true);
            }
        });

        indexChangeListener = (ChangeEvent evt) -> {
            checkIndexStatus();
        };
        
        Indexer.getInstance().addChangeListener(indexChangeListener);
        
        splitPane.setDividerLocation(topPane.getMinimumSize().height);
    }

    
    /** cleanup resource and this component should not be used after a call to this */
    public void dispose() {
        if (indexChangeListener != null)  {
            Indexer.getInstance().removeChangeListener(indexChangeListener);
        }
    }
    
    @Override
    public String getName() {
        if (name != null) {
            return name;
        }
        
        if (bookRenderer == null) {
            return "";
        }
        
        List<Book> books = bookRenderer.getBooks();
        
        if (books.isEmpty()) {
            return "";
        }
        
        StringBuilder sb = new StringBuilder();
        
        for (int i=0;i <books.size(); i++) {
            if (i > 0) {
                sb.append("=");
            } 
            sb.append(books.get(i).getInitials());
        }
        
        return sb.toString();
    }
    
    @Override
    public BookRenderer getBookRenderer() {
        return bookRenderer;
    }

    @Override
    public ViewerHints<ViewerHints.Key,Object> getViewerHints() {
        return bookRenderer.getViewerHints();
    }

    public void setViewerHints(ViewerHints<ViewerHints.Key,Object> viewerHints) {
        bookRenderer.setViewerHints(viewerHints);
    }

    @Override
    public void addHyperlinkListener(HyperlinkListener listener) {
        bookRenderer.addHyperlinkListener(listener);
    }
    
    @Override
    public void removeHyperlinkListener(HyperlinkListener listener) {
        bookRenderer.removeHyperlinkListener(listener);
    }
    
    @Override
    public void openURI(SwordURI uri) {
        openURI(uri, null);
    }

    @Override
    public void openURI(SwordURI uri, String info) {
        //System.out.println("ParallelBookViewerPane.openURI()");
        
        if (uri.getPath().isEmpty()) {
            if (bookRenderer.getBooks().isEmpty()) {
                // try to open preferences default bible
                Book book =  null;
                String bookName = BookViewerOptions.getInstance().getDefaultBible();
                if (bookName != null) {
                    book =  Books.installed().getBook(bookName);
                }
                if (book == null) { 
                    addBookButton.doClick();
                } else {
                    addBook(book.getInitials());
                }
            }
        } else {
            Book book =  Books.installed().getBook(uri.getPath());
            if (book == null) { return; }
            addBook(book.getInitials());
        }

        try {
            if (info != null) {
                searchString = info;
                searching = true;
            }

            if (!uri.getFragment().isEmpty()) {
                //passageTextArea.setText(uri.getFragment());
                //setKey(passageTextArea.getText());
                setKey(uri.getFragment());
            }
        } finally {
            searching = false;
        }
        reload();
    }
    
    /** 
     * Add Book
     * @param bookName Book Initials or Book Name
     * @return true if book is added, otherwise false
     */
    public boolean addBook(String bookName) {
        maximumBook = BookViewerOptions.getInstance().getParallelBookLimit();
        int count = booksComboPane.getComponentCount();
        if (count >= maximumBook) {
            return false;
        }
        
        JComboBox<String> comboBox = createBookComboBox();

        if (bookName == null) {
            bookName = comboBox.getItemAt(0);
        }
        
        Book book = Books.installed().getBook(bookName);
        if (book == null) {
            return false;
        }
        
        comboBox.setSelectedItem(bookName);
        
        bookRenderer.getBooks().add(book);
        if (bookRenderer.getBooks().size() == 1) {
            checkIndexStatus();
        }

        booksComboPane.add(comboBox);
        booksComboPane.revalidate();
        booksComboPane.repaint();
        
        comboBox.addActionListener(bookComboActionListener);

        // try to display something, if this is first book displayed
        if (count == 0 && getKey() == null) {
            initialView(book);
        }
        
        firePropertyChange(BookViewer.VIEWER_NAME, null, getName());
        fireBookChange(new BookChangeEvent(this));
        
        return true;
    }

    /** 
     * This is only called if it is the first book displayed and have not specified
     * any key to be displayed. Try to display something eg: display Gen 1 for bible or commentary
     * @param book Book
     */
    protected void initialView(Book book) {
        Key initialKey = null;

        BookCategory cat = book.getBookCategory();
        if (BookCategory.BIBLE.equals(cat) || BookCategory.COMMENTARY.equals(cat)) {
            // XXX workaround for book.getGlobalKeyList() bug with key,
            // if the locale is not english eg: fa
            // try to display the Gen 1 (chapter)

            // note: need to getValidKey, so history will work
            // getValidKey will convert Verse to Passage
            // see BookViewerHistory constructor
            
            if (BookViewerManager.getInstance().isSynchronizeView()) {
                initialKey = BookViewerManager.getInstance().getSynchronizeKey();
            }

            if (initialKey == null) {
                initialKey = book.getValidKey("Gen 1");
            }

        } else {
            initialKey = book.getGlobalKeyList();
            if (initialKey != null) {
                if (initialKey.getCardinality() > 0) {
                    initialKey = initialKey.get(0);
                }
            }
        }

        if (initialKey == null) {
            return;
        }

        setKey(initialKey);
    }
    
    /** 
     * Remove book at particular index.It do nothing if there is only one book left
     * @param index index at which the specified book is to be removed.
     * @return true if book is removed, otherwise false
     * @throws ArrayIndexOutOfBoundsException - if the index value does not exist.
     */
    public boolean removeBook(int index) {
        int count = booksComboPane.getComponentCount();
        if (count <= 1) {
            return false;
        }
        
        //comboBox.addActionListener(bookComboActionListener);
        //JComboBox<String> comboBox = (JComboBox<String>) booksComboPane.getComponent(index);
        //comboBox.removeActionListener(bookComboActionListener);
        Component comboBox =  booksComboPane.getComponent(index);
        ((JComboBox)comboBox).removeActionListener(bookComboActionListener);
        booksComboPane.remove(index);
        booksComboPane.revalidate();
        booksComboPane.repaint();

        bookRenderer.getBooks().remove(index);
        if (index == 0) {
            checkIndexStatus();
        }
        
        firePropertyChange(BookViewer.VIEWER_NAME, null, getName());
        fireBookChange(new BookChangeEvent(this));

        return true;
    }
    
    /** 
     * Replaces book at particular index
     * @param index index at which the specified book is to be replaced.
     * @param bookName Book Initials or Book Name
     */
    public void setBook(int index, String bookName) {
        Book book = Books.installed().getBook(bookName);
        if (book == null) {
            return;
        }

        bookRenderer.getBooks().set(index, book);
        if (index == 0) {
            checkIndexStatus();
        }

        firePropertyChange(BookViewer.VIEWER_NAME, null, getName());
        fireBookChange(new BookChangeEvent(this));
    }
    
    protected synchronized void checkIndexStatus() {
        unindexedBooks = false;

        // check only first book
        List<Book> books = bookRenderer.getBooks();
        if (!books.isEmpty()) {
            IndexStatus status = books.get(0).getIndexStatus();
            if (!status.equals(IndexStatus.DONE)) {
                unindexedBooks = true;
            }
        }

        /*for (int i=0; i<books.size(); i++) {
            IndexStatus status = books.get(i).getIndexStatus();
            if (!status.equals(IndexStatus.DONE)) {
                unindexedBooks = true;
                break;
            }
        }*/

        //System.out.println("index state: " + unindexedBooks);
        
        CardLayout cl = (CardLayout)searchPane.getLayout();
        if (unindexedBooks) {
            cl.show(searchPane, "index-layout");
        } else {
            cl.show(searchPane, "search-layout");
        }
        searchPane.revalidate();
    }
    
    @Override
    public List<Book> getBooks() {
        List<Book> srcBooks = bookRenderer.getBooks();
        return Collections.unmodifiableList(srcBooks);
    }

    @Override
    public int getBookCount() {
        return bookRenderer.getBooks().size();
    }

    @Override
    public void viewSource() {
        SwingUtilities.invokeLater(() -> {
            try {
                SourceViewerPane sourcePane = new SourceViewerPane();
                sourcePane.initSource(bookRenderer);
                sourcePane.showDialog(this, true);
            } catch (Exception ex) {
                Logger logger = Logger.getLogger(this.getClass().getName());
                logger.log(Level.WARNING, ex.getMessage(), ex);
            }
        });
    }
    
    @Override
    public void compareView(boolean compare) {
        bookRenderer.setCompareView(compare);
        if (compare != compareCheckBox.isSelected()) {
            compareCheckBox.setSelected(compare);
        }
    }

    /** 
     * Return {@code true} or {@code false}
     * @return {@code true} or {@code false}
     */
    @Override
    public boolean isCompareView() {
        return bookRenderer.isCompareView();
    }

    /** 
     * This only set the search field with the param and do nothing aka
     * does not perform searching. If you want actual search call #search(String) instead.
     * It is only used for persisting the session.
     * @param searchString the search text
     * @see #search(String)
     */
    public void setSearchString(String searchString) {
        this.searchString = searchString;
        searchTextArea.setText(searchString);
    }
    
    public String getSearchString() {
        return searchString;
    }
    
    protected void setKey(String keyString) {
        List<Book> books = bookRenderer.getBooks();
        if (!books.isEmpty()) {
            Key key = books.get(0).getValidKey(keyString);
            setKey(key);
        } 
    }
    
    @Override
    public void setKey(Key key) {
        if (key == null) {
            throw new IllegalArgumentException("argument key can't be null");
        }

        Key curKey = bookRenderer.getKey();
        if (curKey != null) {
            if (curKey.toString().equals(key.toString())) {
                return;
            }
        }

        if (!searching) {
            searchString = null;
        }

        Key displayKey = key;
        if (!historyInProgress) {
            BookViewerHistory hist = new BookViewerHistory(key,searchString);
            historyManager.add(hist);
            displayKey = hist.current();

            // XXX, need to refactor this
            GlobalHistory.getInstance().add(hist.getKey().toString(), searchString);

            //BookViewManager.getInstance().synchronizeView(key);
        }

        BookViewerManager.getInstance().synchronizeView(key);
        bookRenderer.setKey(displayKey);

        passageTextArea.setText(key.getName());
        passageTextArea.setCaretPosition(0);

        searchTextArea.setText(searchString);
    }
    
    @Override
    public Key getKey() {
        return bookRenderer.getKey();
    }

    @Override
    public void reload() {
        //System.out.println("ParallelBookViewerPane.refresh()");
        bookRenderer.reload(true);
    }

    public HistoryManager getHistoryManager() {
        return historyManager;
    }
    
    public synchronized void goBack() {
        if (!historyManager.hasBack()) {
            return;
        }
        
        historyInProgress = true;
        try {
            History hist = historyManager.back();
            setKey(hist.getKey());
            searchTextArea.setText(hist.getSearch());
        
            if (hist.getKey() instanceof Passage) {
                bookRenderer.setKey(hist.current());
            }
            
        } finally {
            historyInProgress = false;
        }
        
        reload();
    }
    
    public synchronized void goForward() {
        if (!historyManager.hasForward()) {
            return;
        }
        
        historyInProgress = true;
        try {
            History hist = historyManager.forward();
            setKey(hist.getKey());
            searchTextArea.setText(hist.getSearch());
        
            if (hist.getKey() instanceof Passage) {
                bookRenderer.setKey(hist.current());
            }
        } finally {
            historyInProgress = false;
        }
        reload();
    }
    
    public synchronized void goPrevious() {
        History hist = historyManager.current();
        if (hist == null) {
            return;
        }
        
        if (!hist.hasPrevious()) {
            return;
        }
        
        historyInProgress = true;
        try {
            bookRenderer.setKey(hist.previous());
        } finally {
            historyInProgress = false;
        }
        
        reload();
    }
    
    public synchronized void goNext() {
        History hist = historyManager.current();
        if (hist == null) {
            return;
        }
        
        if (!hist.hasNext()) {
            return;
        }
        
        historyInProgress = true;
        try {
            bookRenderer.setKey(hist.next());
        } finally {
            historyInProgress = false;
        }
        reload();
    }
    
    /** 
     * Expand/Widen currently displayed passage by
     * @param by The number of verses/keys to widen by
     * @param restrict The RestrictionType
     */
    public synchronized void blur(int by, RestrictionType restrict) {
        if (restrict == null) {
            restrict = RestrictionType.NONE;
        }
        
        History hist = historyManager.current();
        if (hist == null) {
            return;
        }
        
        /*historyInProgress = true;
        try {
            hist = historyManager.blur(by, restrict);
            bookRenderer.setKey(hist.current());
            passageTextArea.setText(hist.getKey().getName());
            passageTextArea.setCaretPosition(0);
        } finally {
            historyInProgress = false;
        }
        reload();*/

        try {
            hist = historyManager.blur(by, restrict);
            setKey(hist.current());
            reload();
        } catch (Exception ex) {
            Logger logger = Logger.getLogger(this.getClass().getName());
            logger.log(Level.WARNING, ex.getMessage(), ex);
        }
        
    }

    public void requestFocusForPassageComponent() {
        passageTextArea.selectAll();
        passageTextArea.requestFocusInWindow();
    }

    public void requestFocusForSearchComponent() {
        searchTextArea.selectAll();
        searchTextArea.requestFocusInWindow();
    }

    /** 
     * Display the specified passage
     * @param key the passage key to display
     * @see #viewPassage(String)
     */
    protected void viewPassage(Key key) {
        setKey(key);
        reload();
    }

    /** 
     * Display the specified passage
     * @param passage the passage to display
     * @see #viewPassage(Key)
     */
    protected void viewPassage(String passage) {
        setKey(passage);
        reload();
    }

    /** 
     * Search the specified String which is not ranked
     * @param searchString String to search
     * @see #search(String,boolean,int)
     */
    protected void search(String searchString) {
        search(searchString,false,BookViewerOptions.getInstance().getDefaultSearchLimit());
    }
    
    /** 
     * Search the specified String
     * @param searchString String to search
     * @param ranked true or false
     * @param searchLimit only applicable if ranked is true
     * @see #search(String,boolean,int)
     */
    protected void search(String searchString, boolean ranked, int searchLimit) {
        if (searching) { 
            JOptionPane.showMessageDialog(this, bundle.getString("MSG_SearchInProgress.Text"), bundle.getString("MSG_SearchInProgress.Title"), JOptionPane.ERROR_MESSAGE);
            return; 
        }
        
        searching = true;
        Runnable runnable = () -> {
            ProgressHandle handle = ProgressHandleFactory.createHandle(bundle.getString("MSG_SearchInProgress.Text"), null, null);
            handle.switchToIndeterminate();
            handle.setInitialDelay(500);
            try {
                handle.start();
                searchImpl(searchString, ranked, searchLimit);
            } finally {
                searching = false;
                handle.finish();
            }
        };
        RequestProcessor.getDefault().post(runnable);
    }
    
    private void searchImpl(String searchString, boolean ranked, int searchLimit) {
        if (searchString == null || searchString.length() == 0) {
            return;
        }
        
        List<Book> books = bookRenderer.getBooks();
        if (books.isEmpty()) { 
            JOptionPane.showMessageDialog(this, bundle.getString("MSG_EmptyBooks.Text"), bundle.getString("MSG_EmptyBooks.Title"), JOptionPane.ERROR_MESSAGE);
            return; 
        }

        //boolean ranked = searchLimit <= 0 ? false : true;

        DefaultSearchModifier modifier = new DefaultSearchModifier();
        modifier.setRanked(ranked);
        
        Key results;
        
        try {
            results =  books.get(0).find(new DefaultSearchRequest(searchString, modifier));
        } catch (Exception ex) {
            //Logger logger = Logger.getLogger(this.getClass().getName());
            //logger.log(Level.WARNING, ex.getMessage(), ex);
            JOptionPane.showMessageDialog(this, ex.getMessage(), bundle.getString("MSG_SearchHits.Title"), JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        int total = results.getCardinality();
        int partial = total;
        String msg;
        
        if (total == 0) {
            Object[] args = {searchString};
            msg = MessageFormat.format(bundle.getString("MSG_SearchNoHits.Text"), args);
            JOptionPane.showMessageDialog(this, msg , bundle.getString("MSG_SearchHits.Title"), JOptionPane.INFORMATION_MESSAGE);
            return;
        }

        if (results instanceof PassageTally || ranked)  {
            PassageTally tally = (PassageTally) results;
            tally.setOrdering(PassageTally.ORDER_TALLY);
            
            if (searchLimit > 0 && searchLimit < total)  {
                tally.trimRanges(searchLimit, RestrictionType.NONE);
                partial = searchLimit;
            }
        }

        if (total == partial) {
            Object[] args = {searchString, total};
            msg = MessageFormat.format(bundle.getString("MSG_SearchHits.Text"), args);
            JOptionPane.showMessageDialog(this, msg , bundle.getString("MSG_SearchHits.Title"), JOptionPane.INFORMATION_MESSAGE);
        } else {
            Object[] args = {searchString, partial, total};
            msg = MessageFormat.format(bundle.getString("MSG_SearchPartialHits.Text"), args);
            JOptionPane.showMessageDialog(this, msg , bundle.getString("MSG_SearchHits.Title"), JOptionPane.INFORMATION_MESSAGE);
        }
        
        this.searchString = searchString;
        setKey(results);
        //reload();
        bookRenderer.reload(false);
    }

    /* use for JSword 2.0 
    private void searchImpl(String searchString, boolean ranked, int searchLimit) {
        if (searchString == null || searchString.length() == 0) {
            return;
        }
        
        List<Book> books = bookRenderer.getBooks();
        if (books.isEmpty()) { 
            JOptionPane.showMessageDialog(this, bundle.getString("MSG_EmptyBooks.Text"), bundle.getString("MSG_EmptyBooks.Title"), JOptionPane.ERROR_MESSAGE);
            return; 
        }

        DefaultSearchModifier modifier = new DefaultSearchModifier();
        modifier.setRanked(ranked);

        // If ranking see if the results are being limited.
        int rankCount = searchLimit;
        if (ranked && rankCount != 0) {
            modifier.setMaxResults(rankCount);
        }

        Key results;
        
        try {
            results =  books.get(0).find(new DefaultSearchRequest(searchString, modifier));
        } catch (Exception ex) {
            //Logger logger = Logger.getLogger(this.getClass().getName());
            //logger.log(Level.WARNING, ex.getMessage(), ex);
            JOptionPane.showMessageDialog(this, ex.getMessage(), bundle.getString("MSG_SearchHits.Title"), JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        int partial = results.getCardinality();
        int total = partial;

        // we should get PassageTallys for rank searches
        if (results instanceof PassageTally) {
            PassageTally tally = (PassageTally) results;
            total = tally.getTotal();
            tally.setOrdering(PassageTally.Order.TALLY);
        }

        if (total == 0) {
            Object[] args = {searchString};
            String msg = MessageFormat.format(bundle.getString("MSG_SearchNoHits.Text"), args);
            JOptionPane.showMessageDialog(this, msg , bundle.getString("MSG_SearchHits.Title"), JOptionPane.INFORMATION_MESSAGE);
            return;
        } 
        
        if (total == partial) {
            Object[] args = {searchString, new Integer(total)};
            String msg = MessageFormat.format(bundle.getString("MSG_SearchHits.Text"), args);
            JOptionPane.showMessageDialog(this, msg, bundle.getString("MSG_SearchHits.Title"), JOptionPane.INFORMATION_MESSAGE);
        } else {
            Object[] args = {searchString, new Integer(partial), new Integer(total)};
            String msg = MessageFormat.format(bundle.getString("MSG_SearchPartialHits.Text"), args);
            JOptionPane.showMessageDialog(this, msg, bundle.getString("MSG_SearchHits.Title"), JOptionPane.INFORMATION_MESSAGE);
        }

        this.searchString = searchString;
        setKey(results);
        reload();
    }*/
    
    /** Return JComboBox with book initials sorted by Bible then Commentary 
     * @return JComboBox
     */
    @SuppressWarnings("unchecked")
    protected JComboBox<String> createBookComboBox() {
        List<Book> books = new ArrayList<>();
        List<String> bookInitials = new ArrayList<>();
        Comparator<Book> comparator = SwordUtilities.getBookInitialsComparator();
        
        // bible
        List<Book> tBooks = Books.installed().getBooks(BookFilters.getOnlyBibles());
        books.addAll(tBooks);
        Collections.sort(books, comparator);
        for (int i=0; i<books.size(); i++) {
            bookInitials.add(books.get(i).getInitials());
        }
        
        // Commentary
        books.clear();
        tBooks = Books.installed().getBooks(BookFilters.getCommentaries());
        books.addAll(tBooks);
        Collections.sort(books, comparator);
        if (books.size() > 0) {
            bookInitials.add(SeparatorComboBox.DEFAULT_SEPARATOR);
        }
        for (int i=0; i<books.size(); i++) {
            Book book = books.get(i);
            
            // XXX do not include personal commentary, not supported yet
            if (book.getInitials().toLowerCase().equals("personal")) {
                continue;
            }
            bookInitials.add(book.getInitials());
        }
        
        SeparatorComboBox comboBox = new SeparatorComboBox(bookInitials.toArray(new String[0]));
        comboBox.setPrototypeDisplayValue("BOOKINITIALS"); //NOI18N
        return comboBox;
    }
}
